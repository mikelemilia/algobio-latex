% Overview:
%   DiscoSNP++ TeX subfile for the project.
%   Each subfile MUST start with the following line
%		\documentclass[../main.tex]{subfiles}

\documentclass[../main.tex]{subfiles}

\begin{document}

\subsection{DiscoSnp\texttt{++}}
\paragraph{}
DiscoSnp\texttt{++} \cite{peterlongo2017discosnp++} rientra nella categoria dei metodi \textit{de-novo}, ed è stato presentato come la nuova versione di DiscoSnp \cite{uricaru2015reference}. Reimplementato da zero usando la libreria GATB \cite{drezen2014gatb} permette di ottenere un tempo di esecuzione più veloce ed un minor consumo di memoria rispetto alla sua precedente versione. È stato progettato per individuare e classificare tutte le tipologie di SNP, compresi piccoli indel provenienti direttamente dalle reads sequenziate (FastQ\footnote{FastQ :  formato di puro testo in codice ASCII facilmente leggibile, pensato dal Wellcome Sanger Institute per associare ad una sequenza prodotta da una tecnologia HTS/NGS, la qualità di ogni sua singola base. È diventato lo standard de facto per la condivisione di dati \cite{cock2010sanger}) prodotti da processi di sequenziamento basati su tecnologia HTS. } o FASTA) senza utilizzare un genoma di riferimento.

\paragraph{}  Normalmente DiscoSnp\texttt{++} restituisce gli SNP individuati e classificati nel formato VCF\footnote{VCS : \textbf{scrivere definizione}}, ma opzionalmente può restituirli dopo averli mappati su un genoma di riferimento. Questo può inizialmente apparire in contrasto con un approccio reference free, tuttavia torna particolarmente utile quando si dispone di un genoma di riferimento che non può essere usato per effettuare la chiamata delle varianti (\textbf{variant calling}) tramite tecniche di mappatura ma che può essere usato per posizionare le varianti predette tramite tecniche de-novo. In situazione abbastanza comuni, queste casistiche si presentano quando il genoma di riferimento è stato assemblato male o si sta analizzando un genoma molto distante dalla specie sequenziata. In ogni caso, anche se ci fosse un buon genoma di riferimento, la predizione delle varianti e la genotipizzazione con l'approccio reference free non è influenzato in alcun modo dagli alleli di riferimento.

\subsubsection{Grafo di \textit{Bruijn}}
\label{dBG}
\paragraph{Definizione} Dato un insieme di stringhe $S = \{r_1 , r_2 , ... , r_n\}$ su un alfabeto $\Sigma$ ed un intero $k\geq2$, il grafo di \textit{Bruijn} di ordine $k$ di $S$ $(dBG_k (S))$ è un grafo diretto (o digrafo) $(V,A)$ dove:

\begin{flushleft}
$V = \{d \in \Sigma^k \ |\  \exists i \in \{1, ..., n\} \ tale\ che\ d\ \grave{e}\ una\ sottostringa\ di\ r_i \in S\}$
\linebreak \linebreak
$A = \{ (d,d^\prime)\ |\ se\ il\ suffisso\ di\ lunghezza\ k-1\ di\ d\ \grave{e}\ prefisso\ di\ d^\prime\}$
\end{flushleft}

\paragraph{}Come precedentemente anticipato nella sezione (\nameref{rfm}), i grafi di \textit{Bruijn} sono la struttura dati su cui si basano la maggior parte dei tool Reference Free per la  ricerca di mutazioni (SNP) senza l'utilizzo dell'allinemento, in quanto mutazioni all'interno delle letture generano cammini riconoscibili chiamati "bolle", che possono essere analizzati e classificati (errori di sequenziamento, polimorfismo dovuto a ripetizioni inesatte, reali mutazioni o indel). In particolare, all'interno di un grafo di \textit{Bruijn}, una bolla evidenzia un cammino che diverge in due cammini distinti prima di ricongiungersi e l'analisi di queste bolle risulta cruciale in quanto la ricostruzione di una sequenza di input \textcolor{red}{(read di DNA)} equivale alla ricerca di un cammino hamiltoniano\footnote{Un cammino in un grafo (orientato o non orientato) è detto \textbf{hamiltoniano} se esso tocca tutti i vertici (nodi) del grafo una e una sola volta. Determinare se questo cammino esista è un problema NP-completo. Un grafo che contiene almeno un ciclo hamiltoniano è detto \textbf{grafo hamiltoniano}.} all'interno del grado ed è un noto problema NP-completo. Quindi riuscire ad ottimizzare la ricerca all'interno questa struttura dati è quello che si propone DiscoSnp\texttt{++} tramite i $dBG$ \textit{probabilistici}.

\subsubsection{Struttura dati}

DiscoSnp\texttt{++} basa la sua efficienza sulla struttura dati \textsc{MINIA} \cite{chikhi2013space} che permette di costruire grafi di \textit{Bruijn} probabilistici, ottenuti inserendo tutti i nodi di un grafo di \textit{Bruijn} classico all'interno di filtri Bloom (\textcolor{red}{Bloom Filter}) posti in cascata. All'interno di questa struttura dati, differentemente da un grafo di \textit{Bruijn} classico, gli archi sono dedotti implicitamente dalle interrogazioni fatte ai filtri Bloom (\textcolor{red}{Bloom Filter}) per l'appartenenza di tutte le possibili estensioni di un \textit{k}-mer e non necessitano di essere memorizzati. In particolare, un'estensione di un \textit{k}-mer \textit{v} è la concatenazione di un suffisso $\textit{k}-1$ di \textit{v} con uno dei quattro possibili nucleotidi o di uno dei quattro nucleotidi con il prefisso  $\textit{k}-1$ di \textit{v}. \textsc{MINIA} inoltre supporta un conteggio efficiente ed esatto dei vicini di qualsiasi nodo nel grafo. Pertanto, questo consente di attraversare in modo efficiente il grafo a partire da qualsiasi nodo, in entrambe le direzioni.

\paragraph{}
Nello specifico si concentra sulla ricerca di bolle all'interno del dBG, ovvero due path distinti formati da $k+2$ nodi, che hanno i nodi di diramazione in comune. Più precisamente si definisce nodo di diramazione, o \textit{branching node}, un nodo che ha più di un predecessore e/o più di un successore. Una bolla invece

\subsubsection{Algorithm}

I modelli algoritmici sono stati rivisitati per ottenere un miglior filtraggio degli errori di sequenziamento in modo da individuare nuove varianti.

\subsubsection{Pipeline}

\end{document}